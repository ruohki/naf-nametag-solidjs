<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>OCANIA METAVERSE PERFORMACE</title>
    <meta name="description" content="Nametag â€” Networked-Aframe" />

    <script src="./js/aframe-v1.7.0.min.js"></script>
    <script src="./aframe-super-keyboard/dist/aframe-super-keyboard.js"></script>
    
    <script src="./js/socket.io.min.js"></script>
    <script src="/easyrtc/easyrtc.js"></script>
    <!-- <script src="https://unpkg.com/open-easyrtc@2.1.0/api/easyrtc.js"></script> -->
    <script src="./js/networked-aframe.min.js"></script>

    <script src="./js/aframe-extras.min.js"></script>
    <script src="./js/mirror.js"></script>

    <!--   used for the pretty environment   -->
    <script src="./js/aframe-environment-component.min.js"></script>
    <script src="./js/aframe-text-geometry-component.min.js"></script>
    <script src="./js/spawn-in-circle.js"></script>

    <script src="./aframe-stackbeat_love/aframe-stackbeat_love.js"></script>

    <!--   used to prevent players from spawning on top of each other so much  -->
    <script src="./aframe-resonance-audio-component/aframe-resonance-audio-component.js"></script>
    <script src="./public/js/webmidi.min.js"></script>
 

    <script src="./js/persistent-p2p.component.js"></script>

    <script src="../dist/components.js"></script>
    <script defer src="../dist/ui.js"></script>
    <script>
      // ===== VR CONTROLLER MANAGER =====
      AFRAME.registerComponent('vr-controller-manager', {
        init: function() {
          this.leftHand = null;
          this.rightHand = null;
          this.leftGrabbing = false;
          this.rightGrabbing = false;
          this.leftTarget = null;
          this.rightTarget = null;

          // Wait for scene to load
          this.el.sceneEl.addEventListener('loaded', () => {
            this.leftHand = document.querySelector('#my-tracked-left-hand');
            this.rightHand = document.querySelector('#my-tracked-right-hand');

            if (this.leftHand) {
              this.leftHand.addEventListener('gripdown', this.onLeftGripDown.bind(this));
              this.leftHand.addEventListener('gripup', this.onLeftGripUp.bind(this));
            }

            if (this.rightHand) {
              this.rightHand.addEventListener('gripdown', this.onRightGripDown.bind(this));
              this.rightHand.addEventListener('gripup', this.onRightGripUp.bind(this));
            }
          });
        },

        onLeftGripDown: function() {
          const intersectedEl = this.leftHand.components.raycaster.intersectedEls[0];
          if (intersectedEl && intersectedEl.classList.contains('interactable')) {
            this.leftGrabbing = true;
            this.leftTarget = intersectedEl;
            this.startGrab(this.leftHand, this.leftTarget);
          }
        },

        onLeftGripUp: function() {
          if (this.leftGrabbing && this.leftTarget) {
            this.endGrab(this.leftHand, this.leftTarget);
            this.leftGrabbing = false;
            this.leftTarget = null;
          }
        },

        onRightGripDown: function() {
          const intersectedEl = this.rightHand.components.raycaster.intersectedEls[0];
          if (intersectedEl && intersectedEl.classList.contains('interactable')) {
            this.rightGrabbing = true;
            this.rightTarget = intersectedEl;
            this.startGrab(this.rightHand, this.rightTarget);
          }
        },

        onRightGripUp: function() {
          if (this.rightGrabbing && this.rightTarget) {
            this.endGrab(this.rightHand, this.rightTarget);
            this.rightGrabbing = false;
            this.rightTarget = null;
          }
        },

        startGrab: function(hand, target) {
          console.log('VR Grabbed:', target.id);
          
          // Store initial data
          if (!target.vrGrabData) {
            target.vrGrabData = {};
          }
          target.vrGrabData.hand = hand;
          target.vrGrabData.grabbed = true;
          target.vrGrabData.previousRotation = hand.object3D.rotation.clone();

          // Take ownership
          if (target.components.networked) {
            NAF.utils.takeOwnership(target);
          }

          // Send toggle ON
          const vrRotate = target.components['vr-rotate-interactable'];
          if (vrRotate && vrRotate.data.pdToggle) {
            try {
              Module.pd.sendFloat(vrRotate.data.pdToggle, 1);
              NAF.connection.broadcastData('global-pd', {
                target: vrRotate.data.pdToggle,
                value: 1
              });
            } catch (error) {}
          }
        },

        endGrab: function(hand, target) {
          console.log('VR Released:', target.id);
          
          if (target.vrGrabData) {
            target.vrGrabData.grabbed = false;
            target.vrGrabData.hand = null;
          }

          // Send toggle OFF
          const vrRotate = target.components['vr-rotate-interactable'];
          if (vrRotate && vrRotate.data.pdToggle) {
            try {
              Module.pd.sendFloat(vrRotate.data.pdToggle, 0);
              NAF.connection.broadcastData('global-pd', {
                target: vrRotate.data.pdToggle,
                value: 0
              });
            } catch (error) {}
          }
        }
      });

      //// ===== VR ROTATION =====
      AFRAME.registerComponent('vr-rotate-interactable', {
        schema: {
          pdRotation: { type: 'string' },
          pdToggle: { type: 'string' },
          pdRotation2: { type: 'string' },
          minValue: { type: 'number', default: -40 },
          maxValue: { type: 'number', default: 10 }
        },

        init: function() {
          this.vrGrabData = null;
        },

        tick: function() {
          if (!this.el.vrGrabData || !this.el.vrGrabData.grabbed) return;

          const hand = this.el.vrGrabData.hand;
          if (!hand || !hand.object3D) return;

          const handRotation = hand.object3D.rotation;
          const previousRotation = this.el.vrGrabData.previousRotation;

          // Calculate rotation delta
          const deltaX = handRotation.x - previousRotation.x;
          const deltaY = handRotation.y - previousRotation.y;
          const deltaZ = handRotation.z - previousRotation.z;

          // Apply rotation to object
          const currentRot = this.el.object3D.rotation;
          currentRot.x += deltaX;
          currentRot.y += deltaY;
          currentRot.z += deltaZ;

          // Convert to degrees for A-Frame
          const rotDeg = {
            x: THREE.MathUtils.radToDeg(currentRot.x),
            y: THREE.MathUtils.radToDeg(currentRot.y),
            z: THREE.MathUtils.radToDeg(currentRot.z)
          };

          this.el.setAttribute('rotation', rotDeg);

          // Calculate value for PD (mean of rotations)
          const mean = (rotDeg.x + rotDeg.y + rotDeg.z) / 3;
          const value = this.mapRange(mean, -180, 180, this.data.minValue, this.data.maxValue);

          // Send to PD
          if (this.data.pdRotation) {
            try {
              Module.pd.sendFloat(this.data.pdRotation, value);
              NAF.connection.broadcastData('global-pd', {
                target: this.data.pdRotation,
                value: value
              });
            } catch (error) {}
          }

          if (this.data.pdRotation2) {
            const value2 = this.mapRange(mean, -180, 180, 100, 0);
            try {
              Module.pd.sendFloat(this.data.pdRotation2, value2);
              NAF.connection.broadcastData('global-pd', {
                target: this.data.pdRotation2,
                value: value2
              });
            } catch (error) {}
          }

          // Update previous rotation
          this.el.vrGrabData.previousRotation.copy(handRotation);
        },

        mapRange: function(val, fromMin, fromMax, toMin, toMax) {
          val = Math.max(fromMin, Math.min(fromMax, val));
          const norm = (val - fromMin) / (fromMax - fromMin);
          return toMin + norm * (toMax - toMin);
        }
      });

      AFRAME.registerComponent("position-data", {
        schema: {
          distPl: { type: "number" },
          distP1: { type: "number" },
          distP2: { type: "number" },
          distP3: { type: "number" },
          h1: { type: "number" },
          h2: { type: "number" },
        },

        init: function () {},

        tick: function (time, timeDelta) {
          let players = document.getElementsByClassName("player-rig");

          let player1pos = { x: 0, y: 0, z: 0 };

          if (players.length > 0) {
            for (let i = 0; i < players.length; i++) {
              if (
                players[i].children[0].components[
                  "player-info"
                ].nametag.getAttribute("value") == "Matthias Nowakowski"
              ) {
                try {
                  Module.pd.sendFloat(
                    "r_posx",
                    players[i].getAttribute("position").x / 10
                  );
                } catch (error) {}
                try {
                  Module.pd.sendFloat(
                    "r_posy",
                    (players[i].getAttribute("position").y + 5) / 10
                  );
                } catch (error) {}

                try {
                  Module.pd.sendFloat(
                    "r_posz",
                    (players[i].getAttribute("position").z - 10) / 10
                  );
                } catch (error) {}
              }
              /*
              if (players[i].childNodes.length > 3) {
                if (
                  players[i].childNodes[1].getAttribute("player-info").name ==
                  "#player1"
                ) {
                  player1pos = players[i].getAttribute("position");
                  player1pos.y;

  


                }
              }
              */
            }
          }
        },
      });

      AFRAME.registerComponent("randomize-avatar", {
        schema: { scale: { default: -0.3 } },

        init: function () {
          var scale = Math.random() * (0.2 - -0.4) + -0.4;
          this.el.setAttribute("randomize-avatar", "scale", scale);
          console.log("node", this.el.childNodes[1]);
          if (this.el.childNodes[1]) {
            this.el.childNodes[1].setAttribute(
              "material",
              "displacementScale",
              scale
            );
          }
        },
      });

      <!-- ARCHIPELAGUS START-->
      // A-Frame Random Mesh Component
      // Creates a completely randomized mesh with custom geometry

      AFRAME.registerComponent("random-mesh", {
        schema: {
          // Complexity of the generated mesh
          complexity: { type: "number", default: 5 },

          // Size range
          minSize: { type: "number", default: 0.5 },
          maxSize: { type: "number", default: 1.5 },

          // Color
          randomColor: { type: "boolean", default: true },
          color: { type: "string", default: "#FFFFFF" },

          // Material properties
          wireframe: { type: "boolean", default: false },
          transparent: { type: "boolean", default: false },
          opacity: { type: "number", default: 1.0 },
        },

        init: function () {
          this.createRandomMesh();
        },

        update: function (oldData) {
          // If significant properties changed, recreate the mesh
          if (
            oldData.complexity !== this.data.complexity ||
            oldData.minSize !== this.data.minSize ||
            oldData.maxSize !== this.data.maxSize
          ) {
            // Remove previous mesh if it exists
            if (this.mesh) {
              this.el.removeObject3D("mesh");
            }

            this.createRandomMesh();
          }

          // Update material properties if they changed
          if (
            this.mesh &&
            (oldData.randomColor !== this.data.randomColor ||
              oldData.color !== this.data.color ||
              oldData.wireframe !== this.data.wireframe ||
              oldData.transparent !== this.data.transparent ||
              oldData.opacity !== this.data.opacity)
          ) {
            this.updateMaterialProperties();
          }
        },

        createRandomMesh: function () {
          // Ensure Three.js is available
          if (!THREE) {
            console.error(
              "THREE is not available. Make sure A-Frame is loaded properly."
            );
            return;
          }

          // Create a new geometry
          const geometry = new THREE.BufferGeometry();

          // Number of vertices based on complexity
          const numVertices = this.data.complexity * 10;

          // Generate random vertices
          const vertices = [];
          const normals = [];
          const colors = [];

          // Generate random size within range
          const size =
            Math.random() * (this.data.maxSize - this.data.minSize) +
            this.data.minSize;

          // Create base shape (icosahedron)
          const baseGeometry = new THREE.IcosahedronGeometry(size, 0);
          const basePositions = baseGeometry.getAttribute("position").array;

          // Use base shape vertices as starting points
          for (let i = 0; i < basePositions.length; i += 3) {
            let x = basePositions[i];
            let y = basePositions[i + 1];
            let z = basePositions[i + 2];

            // Randomize position slightly
            x += (Math.random() - 0.5) * size * 0.3;
            y += (Math.random() - 0.5) * size * 0.3;
            z += (Math.random() - 0.5) * size * 0.3;

            vertices.push(x, y, z);

            // Calculate normal (pointing outward from center)
            const length = Math.sqrt(x * x + y * y + z * z);
            normals.push(x / length, y / length, z / length);

            // Add random vertex color
            colors.push(Math.random(), Math.random(), Math.random());
          }

          // Add additional random vertices
          for (let i = 0; i < numVertices; i++) {
            // Generate random spherical coordinates
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const radius = size * (0.7 + Math.random() * 0.3); // Random radius within 70-100% of size

            // Convert to Cartesian coordinates
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);

            vertices.push(x, y, z);

            // Normal (pointing outward from center)
            normals.push(x / radius, y / radius, z / radius);

            // Random color for each vertex
            colors.push(Math.random(), Math.random(), Math.random());
          }

          // Create faces (triangles) by connecting nearby vertices
          const indices = [];

          // Function to calculate distance between vertices
          const distanceBetween = (i, j) => {
            const x1 = vertices[i * 3],
              y1 = vertices[i * 3 + 1],
              z1 = vertices[i * 3 + 2];
            const x2 = vertices[j * 3],
              y2 = vertices[j * 3 + 1],
              z2 = vertices[j * 3 + 2];
            return Math.sqrt(
              (x2 - x1) * (x2 - x1) +
                (y2 - y1) * (y2 - y1) +
                (z2 - z1) * (z2 - z1)
            );
          };

          // Connect vertices from the base icosahedron (they're already in triangle order)
          for (let i = 0; i < basePositions.length / 3; i++) {
            indices.push(i);
          }

          // Connect additional random vertices with nearest neighbors
          const totalVertices = vertices.length / 3;
          for (let i = basePositions.length / 3; i < totalVertices; i++) {
            // Find closest vertices to create triangles
            const distances = [];
            for (let j = 0; j < totalVertices; j++) {
              if (i !== j) {
                distances.push({ index: j, distance: distanceBetween(i, j) });
              }
            }

            // Sort by distance
            distances.sort((a, b) => a.distance - b.distance);

            // Create triangles with closest vertices
            if (distances.length >= 2) {
              indices.push(i, distances[0].index, distances[1].index);

              // Add some additional triangles for more complex shapes
              if (Math.random() > 0.7 && distances.length >= 3) {
                indices.push(i, distances[1].index, distances[2].index);
              }
            }
          }

          // Set attributes
          geometry.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(vertices, 3)
          );
          geometry.setAttribute(
            "normal",
            new THREE.Float32BufferAttribute(normals, 3)
          );
          geometry.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(colors, 3)
          );
          geometry.setIndex(indices);
          geometry.computeVertexNormals(); // Recalculate normals

          // Create material
          const material = new THREE.MeshStandardMaterial({
            vertexColors: true,
            wireframe: this.data.wireframe,
            transparent: this.data.transparent,
            opacity: this.data.opacity,
            roughness: Math.random() * 0.8 + 0.2,
            metalness: Math.random() * 0.5,
          });

          // Override color if not using random per-vertex colors
          if (!this.data.randomColor) {
            material.vertexColors = false;
            material.color = new THREE.Color(this.data.color);
          }

          // Create mesh
          this.mesh = new THREE.Mesh(geometry, material);

          // Add mesh to entity
          this.el.setObject3D("mesh", this.mesh);

          console.log(
            "Created random mesh with",
            vertices.length / 3,
            "vertices and",
            indices.length / 3,
            "triangles"
          );
        },

        updateMaterialProperties: function () {
          if (this.mesh && this.mesh.material) {
            // Update material properties
            this.mesh.material.wireframe = this.data.wireframe;
            this.mesh.material.transparent = this.data.transparent;
            this.mesh.material.opacity = this.data.opacity;

            // Update color settings
            if (this.data.randomColor) {
              this.mesh.material.vertexColors = true;
            } else {
              this.mesh.material.vertexColors = false;
              this.mesh.material.color = new THREE.Color(this.data.color);
            }

            this.mesh.material.needsUpdate = true;
          }
        },

        remove: function () {
          // Clean up when component is removed
          if (this.mesh) {
            this.el.removeObject3D("mesh");
          }
        },
      });
      <!-- -->
      AFRAME.registerComponent("gen-obj", {
        schema: { scale: { default: -0.3 } },

        init: function () {
          var scale = -0.3;
          this.el.setAttribute("gen-obj", "scale", scale);
          console.log("node", this.el.childNodes[1]);
          if (this.el.childNodes[1]) {
            this.el.childNodes[1].setAttribute(
              "material",
              "displacementScale",
              scale
            );
          }
        },
      });
      <!-- ARCHIPELAGUS END-->
    </script>
    <script>
      // Note the way we're establishing the NAF schema here; this is a bit awkward
      // because of a recent bug found in the original handling. This mitigates that bug for now,
      // until a refactor in the future that should fix the issue more cleanly.
      // see issue https://github.com/networked-aframe/networked-aframe/issues/267

      // This one is necessary, because tracking the .head child component's material's color
      // won't happen unless we tell NAF to keep it in sync, like here.
      NAF.schemas.getComponentsOriginal = NAF.schemas.getComponents;
      NAF.schemas.getComponents = (template) => {
        if (!NAF.schemas.hasTemplate("#stackbeat_love-mainsource-template")) {
          NAF.schemas.add({
            template: "#stackbeat_love-mainsource-template",
            components: [
              "position",
              {
                component: "stackbeat_love",
                property: "code",
              },
              {
                component: "sblove_register",
                property: "entity",
              },
              {
                component: "sblove_deregister",
                property: "entity",
              },
            ],
          });
        }
        if (!NAF.schemas.hasTemplate("#stackbeat_love-codesource-template")) {
          NAF.schemas.add({
            template: "#stackbeat_love-codesource-template",
            components: [
              "position",
              "text",
              {
                component: "sblove_register",
                property: "entity",
              },
              {
                component: "sblove_deregister",
                property: "entity",
              },
            ],
          });
        }

        if (!NAF.schemas.hasTemplate("#avatar-template")) {
          NAF.schemas.add({
            template: "#avatar-template",
            components: [
              // position and rotation are added by default if we don't include a template, but since
              // we also want to sync the color, we need to specify a custom template; if we didn't
              // include position and rotation in this custom template, they'd not be synced.
              "position",
              "rotation",
              "player-info",

              // this is how we sync a particular property of a particular component for a particular
              // child element of template instances.
              {
                component: "material",
                property: "displacementScale",
              },
            ],
          });
        }
        //ALBERTO START
        if (!NAF.schemas.hasTemplate("#int-obj-template")) {
          NAF.schemas.add({
            template: "#int-obj-template",
            components: [
              // position and rotation are added by default if we don't include a template, but since
              // we also want to sync the color, we need to specify a custom template; if we didn't
              // include position and rotation in this custom template, they'd not be synced.
              "position",
              "rotation",

              // this is how we sync a particular property of a particular component for a particular
              // child element of template instances.
              {
                component: "material",
                property: "displacementScale",
              },
            ],
          });
        }
        //ALBERTO END

        if (!NAF.schemas.hasTemplate("#bang-template")) {
          NAF.schemas.add({
            template: "#bang-template",
            components: [
              {
                component: "bang",
                property: "bang",
              },
            ],
          });
        }
        if (!NAF.schemas.hasTemplate("#toggle-template")) {
          NAF.schemas.add({
            template: "#toggle-template",
            components: [
              {
                component: "material",
                property: "wireframe",
              },
              {
                component: "toggle",
                property: "toggle",
              },
            ],
          });
        }
        if (!NAF.schemas.hasTemplate("#sld-template")) {
          NAF.schemas.add({
            template: "#sld-template",
            components: [
              {
                component: "pdsld",
                property: "value",
              },
            ],
          });
        }
        if (!NAF.schemas.hasTemplate("#num-template")) {
          NAF.schemas.add({
            template: "#num-template",
            components: [
              {
                component: "num",
                property: "value",
              },
            ],
          });
        }
        if (!NAF.schemas.hasTemplate("#sym-template")) {
          NAF.schemas.add({
            template: "#sym-template",
            components: [
              {
                component: "sym",
                property: "value",
              },
            ],
          });
        }

        const components = NAF.schemas.getComponentsOriginal(template);
        return components;
      };

      AFRAME.registerComponent("distance-to-obj", {
        schema: {
          playerSelector: { type: "string", default: "#player-rig" },
          distanceThreshold: { type: "number", default: 5 },
          onBangName: { type: "string", default: "b1on-r" },
          offBangName: { type: "string", default: "b1off-r" },
          positionThreshold: { type: "number", default: 0.01 }, // Minimum movement to trigger update
        },

        init: function () {
          this.playerEl = document.querySelector(this.data.playerSelector);
          this.isAboveThreshold = false;

          // Initialize last processed positions
          this.lastProcessedPlayerPosition = new THREE.Vector3();
          this.lastProcessedCubePosition = new THREE.Vector3();

          // Set initial positions
          if (this.playerEl) {
            this.lastProcessedPlayerPosition.copy(
              this.playerEl.object3D.position
            );
          }
          this.lastProcessedCubePosition.copy(this.el.object3D.position);
        },

        tick: function () {
          if (!this.playerEl) return;

          const playerPos = this.playerEl.object3D.position;
          const cubePos = this.el.object3D.position;
          const posThreshold = this.data.positionThreshold;

          // Only process if either player or cube moved significantly
          if (
            playerPos.distanceToSquared(this.lastProcessedPlayerPosition) >
              posThreshold * posThreshold ||
            cubePos.distanceToSquared(this.lastProcessedCubePosition) >
              posThreshold * posThreshold
          ) {
            // Update last processed positions
            this.lastProcessedPlayerPosition.copy(playerPos);
            this.lastProcessedCubePosition.copy(cubePos);

            // Calculate distance without using Math.abs and Math.pow for better performance
            const dx = playerPos.x - cubePos.x;
            const dy = playerPos.y - cubePos.y;
            const dz = playerPos.z - cubePos.z;
            const totalDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            // Check if state has changed
            const currentlyAboveThreshold =
              totalDistance > this.data.distanceThreshold;

            // Only send bang when crossing the threshold
            if (currentlyAboveThreshold && !this.isAboveThreshold) {
              // We just crossed above the threshold
              try {
                Module.pd.sendBang(this.data.offBangName);

                // Broadcast to all peers
                NAF.connection.broadcastData("global-pd", {
                  target: this.data.offBangName + "-broadcast",
                  value: 1,
                });
              } catch (error) {
                console.warn("Error sending PD bang:", error);
              }
            } else if (!currentlyAboveThreshold && this.isAboveThreshold) {
              // We just crossed below the threshold
              try {
                Module.pd.sendBang(this.data.onBangName);

                // Broadcast to all peers
                NAF.connection.broadcastData("global-pd", {
                  target: this.data.onBangName + "-broadcast",
                  value: 1,
                });
              } catch (error) {
                console.warn("Error sending PD bang:", error);
              }
            }

            // Update our state for next time
            this.isAboveThreshold = currentlyAboveThreshold;
          }
        },
      });

      AFRAME.registerComponent("global-pd-manager", {
        init: function () {
          this.handleEvent = this.handleEvent.bind(this);

          // Subscribe to a single global channel
          NAF.connection.subscribeToDataChannel("global-pd", this.handleEvent);
          console.log("Subscribed to global-pd channel");
        },

        handleEvent: function (senderId, dataType, data) {
          // Skip own events
          if (senderId === NAF.clientId) return;

          // Only process if we have the target and value
          if (data.target && data.value !== undefined) {
            console.log("RECEIVED:", data.target, data.value);

            // Handle special bang broadcast messages
            if (data.target.endsWith("-broadcast") && data.value === 1) {
              const bangName = data.target.replace("-broadcast", "");
              if (typeof Module !== "undefined" && Module.pd) {
                Module.pd.sendBang(bangName);
              }
            }
            // Regular float messages
            else if (typeof Module !== "undefined" && Module.pd) {
              Module.pd.sendFloat(data.target, data.value);
            }
          }
        },
      });

      /////////////////////

      AFRAME.registerComponent("simple-rotate", {
        schema: {
          pdRotation: { type: "string" },
          pdToggle: { type: "string" },
          pdRotation2: { type: "string" },
          minValue: { type: "number", default: -40 },
          maxValue: { type: "number", default: 10 },
        },

        init: function () {
          this.onKeyDown = this.onKeyDown.bind(this);
          this.onKeyUp = this.onKeyUp.bind(this);
          this.onMouseDown = this.onMouseDown.bind(this);
          this.onMouseMove = this.onMouseMove.bind(this);
          this.onMouseUp = this.onMouseUp.bind(this);

          this.isShiftDown = false;
          this.isDragging = false;
          this.lastPos = { x: 0, y: 0 };

          document.addEventListener("keydown", this.onKeyDown);
          document.addEventListener("keyup", this.onKeyUp);

          console.log("Simple-rotate initialized on", this.el.id);
        },

        onKeyDown: function (evt) {
          if (evt.key === "Shift") {
            this.isShiftDown = true;

            // Add click listeners only when shift is pressed
            document.addEventListener("mousedown", this.onMouseDown);
          }
        },

        onKeyUp: function (evt) {
          if (evt.key === "Shift") {
            this.isShiftDown = false;
            this.isDragging = false;

            // Remove click listeners when shift is released
            document.removeEventListener("mousedown", this.onMouseDown);
            document.removeEventListener("mousemove", this.onMouseMove);
            document.removeEventListener("mouseup", this.onMouseUp);
          }
        },

        onMouseDown: function (evt) {
          // Check if this object was clicked
          var mouse = new THREE.Vector2();
          var raycaster = new THREE.Raycaster();
          var canvas = this.el.sceneEl.canvas;
          var bounds = canvas.getBoundingClientRect();

          mouse.x = ((evt.clientX - bounds.left) / bounds.width) * 2 - 1;
          mouse.y = -((evt.clientY - bounds.top) / bounds.height) * 2 + 1;

          raycaster.setFromCamera(mouse, this.el.sceneEl.camera);
          var intersects = raycaster.intersectObject(this.el.object3D, true);

          if (intersects.length > 0) {
            console.log("Selected", this.el.id);
            this.isDragging = true;
            this.lastPos.x = evt.clientX;
            this.lastPos.y = evt.clientY;

            // Add move and up listeners
            document.addEventListener("mousemove", this.onMouseMove);
            document.addEventListener("mouseup", this.onMouseUp);

            // Take ownership
            if (this.el.components.networked) {
              NAF.utils.takeOwnership(this.el);
            }

            // Send toggle ON
            if (this.data.pdToggle) {
              console.log("SENDING toggle:", this.data.pdToggle, 1);
              try {
                Module.pd.sendFloat(this.data.pdToggle, 1);

                // Broadcast
                NAF.connection.broadcastData("global-pd", {
                  target: this.data.pdToggle,
                  value: 1,
                });
              } catch (error) {}
            }

            evt.preventDefault();
            evt.stopPropagation();
          }
        },

        onMouseMove: function (evt) {
          if (!this.isDragging) return;

          // Calculate deltas
          var dx = evt.clientX - this.lastPos.x;
          var dy = evt.clientY - this.lastPos.y;

          // Apply rotation
          var rot = this.el.getAttribute("rotation") || { x: 0, y: 0, z: 0 };
          var newRot = {
            x: rot.x + dy * 0.5,
            y: rot.y - dx * 0.5,
            z: rot.z,
          };

          this.el.setAttribute("rotation", newRot);

          // Calculate value for PD
          var mean = (newRot.x + newRot.y + newRot.z) / 3;
          var value = this.mapRange(
            mean,
            -180,
            180,
            this.data.minValue,
            this.data.maxValue
          );

          // Send to PD
          if (this.data.pdRotation) {
            console.log("SENDING rotation:", this.data.pdRotation, value);
            Module.pd.sendFloat(this.data.pdRotation, value);

            // Broadcast
            NAF.connection.broadcastData("global-pd", {
              target: this.data.pdRotation,
              value: value,
            });
          }

          var value1 = this.mapRange(mean, -180, 180, 100, 0);

          // Send to PD
          if (this.data.pdRotation2) {
            //console.log('SENDING rotation:', this.data.pdRotation, value);
            try {
              Module.pd.sendFloat(this.data.pdRotation2, value1);
            } catch (error) {}

            // Broadcast
            NAF.connection.broadcastData("global-pd", {
              target: this.data.pdRotation2,
              value: value1,
            });
          }

          this.lastPos.x = evt.clientX;
          this.lastPos.y = evt.clientY;
        },

        onMouseUp: function () {
          console.log("Released", this.el.id);
          this.isDragging = false;

          // Remove listeners
          document.removeEventListener("mousemove", this.onMouseMove);
          document.removeEventListener("mouseup", this.onMouseUp);

          // Send toggle OFF
          if (this.data.pdToggle) {
            console.log("SENDING toggle OFF:", this.data.pdToggle, 0);
            try {
              Module.pd.sendFloat(this.data.pdToggle, 0);
            } catch (error) {}

            // Broadcast
            NAF.connection.broadcastData("global-pd", {
              target: this.data.pdToggle,
              value: 0,
            });
          }
        },

        mapRange: function (val, fromMin, fromMax, toMin, toMax) {
          val = Math.max(fromMin, Math.min(fromMax, val));
          var norm = (val - fromMin) / (fromMax - fromMin);
          return toMin + norm * (toMax - toMin);
        },

        remove: function () {
          document.removeEventListener("keydown", this.onKeyDown);
          document.removeEventListener("keyup", this.onKeyUp);
          document.removeEventListener("mousedown", this.onMouseDown);
          document.removeEventListener("mousemove", this.onMouseMove);
          document.removeEventListener("mouseup", this.onMouseUp);
        },
      });

      // Helper component to mark objects as interactable
      AFRAME.registerComponent("interactable", {
        init: function () {
          this.el.classList.add("interactable");
          console.log(
            "Added interactable class to " + (this.el.id || "unnamed entity")
          );
        },
      });
      <!-- ARCHIPELAGUS END -->
    </script>
  </head>

  <body>
    <script src="a-pdxr.js"></script>
    <!--   <input
      id="username-overlay"
      style="z-index: 100; bottom: 24px; left: 48px; position: fixed"
      oninput="document.getElementById('player').setAttribute('player-info', 'name', this.value)"
      value="User Name"
    /> -->
    <a-scene
      persistent-p2p
      networked-scene="
      room: basic;
      debug: true;
      adapter: wseasyrtc;
    "
      shadow="enabled:false;"
      global-pd-manager
    >
      <a-assets>
        <img
          crossorigin="anonymous"
          id="floor_tex"
          src="export_jitter.jpg"
        />
        <a-asset-item
          id="island"
          src="Untitled_Scan_17_18_41.gltf"
        ></a-asset-item>
        <!--
        <a-asset-item
          id="island2"
          src="https://cdn.glitch.global/9c64e9b8-036d-4551-bc8b-f0e3466712bb/Untitled_Scan_17_24_42.gltf?v=1743348418483"
        ></a-asset-item>
-->
        <a-asset-item
          id="island3"
          src="Untitled_Scan_17_25_56.gltf"
        ></a-asset-item>
        <a-asset-item
          id="avatar"
          src="avatar.obj"
        ></a-asset-item>

        <!-- Templates -->
        <template id="stackbeat_love-mainsource-template">
          <a-entity
            class="raycastable"
            geometry="primitive: sphere;radius:10"
            material="wireframe:true;color:red"
            text="value:Hello World;side:double"
            resonance-audio-src="
            src:;
            loop: true;
            autoplay: true;"
            stackbeat_love=""
            sblove_register=""
            sblove_deregister=""
            sblove_destroy
          >
          </a-entity>
        </template>
        <template id="stackbeat_love-codesource-template">
          <a-entity
            class="raycastable"
            geometry="primitive: box;"
            material="wireframe:true;"
            sblove_destroy
            sblove_register=""
            sblove_deregister=""
            text
          >
          </a-entity>
        </template>
        <!-- Camera Rig / Player -->
        <template id="rig-template">
          <a-entity class="player-rig"></a-entity>
        </template>

        <!-- Head / Avatar -->
        <template id="avatar-template">
          <a-entity class="avatar" randomize-avatar>
            <a-entity
              obj-model="obj: #avatar"
              scale="13 13 13"
              material="color: #FFFF55; displacementMap: #floor_tex; displacementScale: -0.3; displacementBias: 0.0; roughness: 0.2;metalness: 0.6;"
              position="0 -1.3 0.3"
            >
            </a-entity>
            <a-text
              class="nametag"
              value="?"
              align="center"
              rotation="0 180 0"
              position="0 1.8 0.3"
              side="double"
              scale="2.5 2.5 2.5"
            ></a-text>
          </a-entity>
        </template>

        <!-- ARCHIPELAGUS START -->

        <template id="cube-template">
          <a-entity class="interactable" interactable>
            <a-entity scale="5 5 5" position="0 0 0"> </a-entity>
          </a-entity>
        </template>

        <template id="sphere-template">
          <a-entity class="interactable" interactable>
            <a-entity scale="5 5 5" position="0 0 0"> </a-entity>
          </a-entity>
        </template>

        <template id="cone-template">
          <a-entity class="interactable" interactable>
            <a-entity scale="5 5 5" position="0 0 0"> </a-entity>
          </a-entity>
        </template>

        <template id="int-obj-template">
          <a-entity class="interactable" interactable>
            <a-entity position="0 0 0" rotation="0 0 0"> </a-entity>
          </a-entity>
        </template>

        <!-- ARCHIPELAGUS END -->

        <!-- 

             Templates of PD GUI Objects

             change visual appearance here.  

        -->

        <template id="bang-template">
          <a-entity
            class="collidable"
            geometry="primitive: icosahedron"
            material="color: #00ffff; emissive: #000000; metalness: 0.91; roughness: 0.4"
            bang
            animation="property: material.color; from: #00ffff; to: #000000; dur: 50; dir: reverse; startEvents: pdbng_glow"
            animation__2="property: bang.bang;from: 1; to: 0; delay: 50; dur: 1; startEvents: pdbng_false"
          >
          </a-entity>
        </template>
        <template id="num-template">
          <a-entity
            geometry="primitive: box"
            material="wireframe: true; color: white"
            num
          >
          </a-entity>
        </template>
        <template id="sym-template">
          <a-entity
            geometry="primitive: box"
            material="wireframe: true; color: white"
            sym
          >
          </a-entity>
        </template>
        <template id="toggle-template">
          <a-entity
            class="collidable"
            geometry="primitive: box"
            material="wireframe: true; color: white"
            toggle
          >
          </a-entity>
        </template>
        <template id="sld-template">
          <a-entity
            geometry="primitive: box; height:4"
            material="color: #00ffff; emissive: #000000; metalness: 0.91; roughness: 0.4;wireframe:true"
            scale="0.5 0.5 0.5"
          >
            <a-entity
              class="collidable"
              geometry="primitive: box; height:0.5"
              material="color: #00ffff; emissive: #000000; metalness: 0.91; roughness: 0.4"
              position="0 2.25 0"
              slideup
              animation="property:material.color; from: #00ffff; to: #000000; dur:50; dir:reverse; startEvents: pdsldup_glow"
            ></a-entity>
            <a-entity
              geometry="primitive: box; height:0.1"
              material="color: #00ffff; emissive: #000000; metalness: 0.91; roughness: 0.4;wireframe:false"
              position="0 0 0"
              slider
            ></a-entity>
            <a-entity
              class="collidable"
              geometry="primitive: box; height:0.5"
              material="color: #00ffff; emissive: #000000; metalness: 0.91; roughness: 0.4;wireframe:false"
              position="0 -2.25 0"
              slidedwn
              animation="property:material.color; from: #00ffff; to: #000000; dur:50; dir:reverse; startEvents: pdslddwn_glow"
            ></a-entity>
          </a-entity>
        </template>
      </a-assets>

      <a-resonance-audio-room
        position="0 2.5 0"
        width="100"
        height="80"
        depth="100"
        ambisonic-order="3"
        speed-of-sound="343"
        left="acoustic-ceiling-tiles"
        right="acoustic-ceiling-tiles"
        front="acoustic-ceiling-tiles"
        back="acoustic-ceiling-tiles"
        down="acoustic-ceiling-tiles"
        up="acoustic-ceiling-tiles"
        visualize="false"
      >
        <a-pdxr-audiochannel
          id="pdxr-ch3"
          position="4 -10 5"
          rotation=""
          resonance-audio-src="gain:1;visualize:false"
        ></a-pdxr-audiochannel>
        <a-pdxr-audiochannel
          id="pdxr-ch4"
          position="9 -10 5"
          rotation=""
          resonance-audio-src="gain:1;visualize:false"
        ></a-pdxr-audiochannel>
      </a-resonance-audio-room>

      <a-entity
        environment="ground:none;skyType:gradient;skyColor:#AA00AA;horizonColor:#DDDDDD;fog:0.3;lighting:distant;"
        hide-on-enter-ar
      ></a-entity>
      <a-light
        type="directional"
        light="color: #ffffff; intensity: 1.22;"
        position="1 -0.46 1"
        intensity="0.9"
      ></a-light>
      <a-entity
        light="color: #AA00AA; intensity: 0.1; type: ambient"
        intensity="0.2"
      ></a-entity>

      <a-entity
        gltf-model="#island"
        scale="100 100 100"
        position="-25 0.09 -150"
      ></a-entity>
      <!--
      <a-entity
        gltf-model="#island2"
        scale="100 100 100"
        position="40 10 0"
        rotation="0 -90 0"
      ></a-entity> -->
      <a-entity
        gltf-model="#island3"
        scale="100 100 100"
        position="100 -25.97 60"
        rotation="0 -9.54 0"
      ></a-entity>

      <a-torus-knot
        color="#AA00AA"
        geometry="q: 3.41; radius: 90; radiusTubular: 10; segmentsTubular: 200;segmentsRadial:30"
        material="metalness: 0.3;roughness:0.4"
        position="-40.18 -42 -26.5"
      ></a-torus-knot>

      <a-entity
        id="floor"
        geometry="segmentsHeight: 10; segmentsWidth: 10; segmentsDepth: 2"
        rotation="-90 0 0"
        scale="200 200 30"
        material="opacity: 0.8; repeat: 2 2; side: double; transparent: true; color: #00AA00; displacementMap: #floor_tex; displacementScale: -0.4; displacementBias: 0.4; emissive: #00AAAA; emissiveIntensity: 0.37; metalness: 0.3; roughness: 0.44; src: #floor_tex"

      ></a-entity>

      <!--         animation="property: material.repeat; from: 2 2; to: 2.1 2.1; loop: true; ease:linear;dir:alternate;dur: 13000"
        animation__2="property: material.displacementBias; from: 0.4; to: 0.45; loop: true; ease:linear;dir:alternate;dur: 5000" -->
      
      <a-entity
        animation="property: rotation; to: 0 360 0; loop: true; dur: 53000;easing:linear"
        position="-7 0 -75"
      >
        <a-entity
          text-geometry="value: OCANIA"
          material="color:#AA00AA;wireframe:false;displacementMap:#floor_tex;displacementScale:0.1"
          scale="15 15 15"
          position="-20 0 0"
          ><a-entity
            text-geometry="value: OCANIA"
            material="color:black;wireframe:true"
          ></a-entity
        ></a-entity>
      </a-entity>

      <a-entity
        id="player-rig"
        networked="template:#rig-template;"
        position="0 1.6 0"
        stackbeat_love-drop
        cursor="rayOrigin:mouse;"
        movement-controls="fly:true;speed:0.1"
        raycaster="objects: .collidable, .raycastable"
        position-data
        vr-controller-manager
      >
        <!--         movement-controls="fly:true;"
-->
        <a-entity
          id="player"
          camera
          look-controls
          networked="template:#avatar-template;"
          visible="true"
          player-info
          follow-ui
        >
        </a-entity>
        <a-entity
          id="my-tracked-left-hand"
          networked="template:#left-hand-default-template"
          laser-controls="hand: left"
          oculus-touch-controls="hand: left"
          vive-controls="hand: left"
          raycaster="objects: .collidable, .raycastable, .interactable; far: 10"
        ></a-entity>
        <a-entity
          id="my-tracked-right-hand"
          networked="template:#right-hand-default-template"
          laser-controls="hand: right"
          oculus-touch-controls="hand: right"
          vive-controls="hand: right"
          raycaster="objects: .collidable, .raycastable, .interactable; far: 10"
        ></a-entity>
      </a-entity>


      <!-- Bubbles START -->

      <a-entity
        id="distance-cube"
        position="10.39716 6.77741 7.00054"
        geometry=""
        normal-map="#normalMap"
        random-mesh="complexity: 2; minSize: 0.2; maxSize: 0.55"
        distance-to-obj="distanceThreshold: 2; onBangName: d4on-r; offBangName: d4off-r"
      >
      </a-entity>

      <a-entity
        id="distance-cube-1a"
        position="9.00648 6.88751 14.49125"
        geometry=""
        normal-map="#normalMap"
        random-mesh="minSize: 0.2; maxSize: 0.55"
        distance-to-obj="distanceThreshold: 2; onBangName: c1on-r; offBangName: c1off-r"
      >
      </a-entity>

      <a-entity
        id="distance-cube-1"
        position="11.07165 5.23535 6"
        geometry=""
        normal-map="#normalMap"
        random-mesh="complexity: 2; minSize: 0.2; maxSize: 0.55"
        distance-to-obj="distanceThreshold: 2; onBangName: b2on-r; offBangName: b2off-r"
      >
      </a-entity>

      <a-entity
        id="distance-cube-1b"
        position="6.3661 4.66399 2"
        geometry=""
        normal-map="#normalMap"
        random-mesh="minSize: 0.55; maxSize: 0.75"
        distance-to-obj="distanceThreshold: 2; onBangName: d1on-r; offBangName: d1off-r"
      >
      </a-entity>

      <a-entity
        id="distance-cube-2"
        position="-2.67556 4.05208 4"
        geometry=""
        normal-map="#normalMap"
        random-mesh="complexity: 2; minSize: 0.55; maxSize: 0.75"
        distance-to-obj="distanceThreshold: 2; onBangName: b3on-r; offBangName: b3off-r"
      >
      </a-entity>

      <a-entity
        id="distance-cube-2a"
        position="15.26412 4.52784 -2"
        geometry=""
        normal-map="#normalMap"
        random-mesh="minSize: 0.55; maxSize: 0.75"
        distance-to-obj="distanceThreshold: 2; onBangName: c2on-r; offBangName: c2off-r"
      >
      </a-entity>

      <a-entity
        id="distance-cube-3"
        position="8.47517 4.60661 -4"
        geometry=""
        normal-map="#normalMap"
        random-mesh="complexity: 2; minSize: 0.55; maxSize: 0.75"
        distance-to-obj="distanceThreshold: 2; onBangName: b4on-r; offBangName: b4off-r"
      >
      </a-entity>

      <a-entity
        id="distance-cube-2b"
        position="5.35743 5.84704 8.48024"
        geometry=""
        normal-map="#normalMap"
        random-mesh="minSize: 0.55; maxSize: 0.75"
        distance-to-obj="distanceThreshold: 2; onBangName: d2on-r; offBangName: d2off-r"
      >
      </a-entity>

      <a-entity
        id="distance-cube-4"
        position="-1.00427 6.7321 0.7606"
        geometry=""
        normal-map="#normalMap"
        random-mesh="minSize: 0.55; maxSize: 0.75"
        distance-to-obj="distanceThreshold: 2; onBangName: b5on-r; offBangName: b5off-r"
      >
      </a-entity>

      <a-entity
        id="distance-cube-3a"
        position="13.71487 5.01237 9.32566"
        geometry=""
        normal-map="#normalMap"
        random-mesh="complexity: 2; minSize: 0.55; maxSize: 0.75"
        distance-to-obj="distanceThreshold: 2; onBangName: c3on-r; offBangName: c3off-r"
      >
      </a-entity>

      <a-entity
        id="distance-cube-3b"
        position="8.04871 8 10"
        geometry=""
        normal-map="#normalMap"
        random-mesh="minSize: 0.55; maxSize: 0.75"
        distance-to-obj="distanceThreshold: 2; onBangName: d3on-r; offBangName: d3off-r"
      >
      </a-entity>
      <!-- ARCHIPELAGUS END -->

      <!-- Choir START -->
      
      <!------============================-------->
      <a-entity position="14 0 20" rotation="0 40 0">
        <a-entity
          geometry="primitive: dodecahedron;radius: 0.5"
          visible="true"
          id="sphere1a"
          class="interactable"
          interactable
          position="-1 -0.8 -4"
          normal-map="#normalMap"
          material="color: #FF55FF; emissive: #000000; metalness: 0.91; roughness: 0.4"
          rotation="0 0 0"
          networked="template: #sphere-template, #int-obj-template; networkId: sphere1a"
          simple-rotate="pdRotation: faa-s; pdToggle: tfaa-s; minValue: -40; maxValue: 0"
          vr-rotate-interactable="pdRotation: faa-s; pdToggle: tfaa-s; minValue: -40; maxValue: 0"
        ></a-entity>

        <a-entity
          geometry="primitive: dodecahedron;radius: 0.5"
          visible="true"
          id="sphere1b"
          class="interactable"
          interactable
          position="1 -0.8 -4"
          normal-map="#normalMap"
          material="color: #ffff13; emissive: #000000; metalness: 0.91; roughness: 0.4"
          rotation="0 0 0"
          networked="template: #sphere-template, #int-obj-template; networkId: sphere1b"
          simple-rotate="pdRotation: faa1-s; pdToggle: tfaa1-s; minValue: -40; maxValue: 0"
          vr-rotate-interactable="pdRotation: faa1-s; pdToggle: tfaa1-s; minValue: -40; maxValue: 0"
        ></a-entity>

        <a-entity
          geometry="primitive: dodecahedron;radius: 0.5"
          visible="true"
          id="sphere1c"
          class="interactable"
          interactable
          position="0 -0.7 -5"
          normal-map="#normalMap"
          material="color: #55FF55; emissive: #000000; metalness: 0.91; roughness: 0.4"
          rotation="0 0 0"
          networked="template: #sphere-template, #int-obj-template; networkId: sphere1c"
          simple-rotate="pdRotation: faa2-s; pdToggle: tfaa2-s; minValue: -40; maxValue: 0"
          vr-rotate-interactable="pdRotation: faa2-s; pdToggle: tfaa2-s; minValue: -40; maxValue: 0"
        ></a-entity>

        <a-entity
          geometry="primitive: tetrahedron; radius: 0.5"
          visible="true"
          id="box1a"
          class="interactable"
          interactable
          position="-1 0.7 -4"
          normal-map="#normalMap"
          material="color: #FF55FF; emissive: #000000; metalness: 0.91; roughness: 0.4"
          rotation="0 0 0"
          networked="template: #cube-template, #int-obj-template; networkId: box1a"
          simple-rotate="pdRotation: va-s; pdToggle: ta-s; minValue: 0; maxValue: 100"
          vr-rotate-interactable="pdRotation: va-s; pdToggle: ta-s; minValue: 0; maxValue: 100"
        ></a-entity>

        <a-entity
          geometry="primitive: tetrahedron; radius: 0.5"
          visible="true"
          id="box1b"
          class="interactable"
          interactable
          position="1 0.7 -4"
          normal-map="#normalMap"
          material="color:#ffff13; emissive: #000000; metalness: 0.91; roughness: 0.4"
          rotation="0 0 0"
          networked="template: #cube-template, #int-obj-template; networkId: box1b"
          simple-rotate="pdRotation: va1-r; pdToggle: ta1-s;minValue: 0; maxValue: 100"
          vr-rotate-interactable="pdRotation: va1-r; pdToggle: ta1-s;minValue: 0; maxValue: 100"
        ></a-entity>

        <a-entity
          geometry="primitive: tetrahedron; radius: 0.5"
          visible="true"
          id="box1c"
          class="interactable"
          interactable
          position="0 0.7 -5"
          normal-map="#normalMap"
          material="color: #55FF55; emissive: #000000; metalness: 0.91; roughness: 0.4"
          rotation="0 0 0"
          networked="template: #cube-template, #int-obj-template; networkId: box1c"
          simple-rotate="pdRotation: va2-r; pdToggle: ta2-s;minValue: 0; maxValue: 100"
          vr-rotate-interactable="pdRotation: va2-r; pdToggle: ta2-s;minValue: 0; maxValue: 100"
        ></a-entity>

        <a-entity
          position="0 -2 -4.5"
          geometry="primitive:sphere;segmentsHeight: 10; segmentsWidth: 10; segmentsDepth: 2"
          rotation="0 0 0"
          scale="3 0.5 3"
          material="opacity: 0.8; repeat: 2 2; side: double; transparent: true; color: #00AA00;  displacementMap: #floor_tex; displacementScale: -0.4; displacementBias: 0.4;emissive: #00AAAA; emissiveIntensity: 0.37; metalness: 0.3; roughness: 0.44; src: #floor_tex"
        ></a-entity>
      </a-entity>

      <!-- choir 2 -->

      <a-entity position="-1 0 -10" rotation="0 -40 0">
        <a-entity
          geometry="primitive: dodecahedron;radius: 0.5"
          visible="true"
          id="sphere2a"
          class="interactable"
          interactable
          position="3 -0.7 0"
          normal-map="#normalMap"
          material="color:  #FF55FF; emissive: #000000; metalness: 0.91; roughness: 0.4"
          rotation="0 0 0"
          networked="template: #sphere-template, #int-obj-template; networkId: sphere2a"
          simple-rotate="pdRotation: fe-s; pdToggle: tfe-s; minValue: -40; maxValue: 0"
          vr-rotate-interactable="pdRotation: fe-s; pdToggle: tfe-s; minValue: -40; maxValue: 0"
        ></a-entity>

        <a-entity
          geometry="primitive: dodecahedron;radius: 0.5"
          visible="true"
          id="sphere2b"
          class="interactable"
          interactable
          position="4 -0.8 1"
          normal-map="#normalMap"
          material="color: #55FF55; emissive: #000000; metalness: 0.91; roughness: 0.4"
          rotation="0 0 0"
          networked="template: #sphere-template, #int-obj-template; networkId: sphere2b"
          simple-rotate="pdRotation: fe1-s; pdToggle: tfe1-s; minValue: -40; maxValue: 0"
          vr-rotate-interactable="pdRotation: fe1-s; pdToggle: tfe1-s; minValue: -40; maxValue: 0"
        ></a-entity>

        <a-entity
          geometry="primitive: tetrahedron; radius: 0.5"
          visible="true"
          id="cube2a"
          class="interactable"
          interactable
          position="3 0.7 0"
          normal-map="#normalMap"
          material="color:  #FF55FF; emissive: #000000; metalness: 0.91; roughness: 0.4"
          rotation="0 0 0"
          networked="template: #cube-template, #int-obj-template; networkId: cube2a"
          simple-rotate="pdRotation: ve-r; pdToggle: te-s; minValue: 0; maxValue: 100"
          vr-rotate-interactable="pdRotation: ve-r; pdToggle: te-s; minValue: 0; maxValue: 100"
        ></a-entity>

        <a-entity
          geometry="primitive: tetrahedron; radius: 0.5"
          visible="true"
          id="cube2b"
          class="interactable"
          interactable
          position="4 0.7 1"
          rotation="0 0 0"
          networked="template: #cube-template, #int-obj-template; networkId: cube2b"
          simple-rotate="pdRotation: ve1-r; pdToggle: te1-s; minValue: 0; maxValue: 100"
          vr-rotate-interactable="pdRotation: ve1-r; pdToggle: te1-s; minValue: 0; maxValue: 100"
          normal-map="#normalMap"
          material="color: #55FF55; emissive: #000000; metalness: 0.91; roughness: 0.4"
        ></a-entity>

        <a-entity
          geometry="primitive: tetrahedron; radius: 0.5"
          visible="true"
          id="cube2c"
          class="interactable"
          interactable
          position="3 0.7 2"
          normal-map="#normalMap"
          material="color: #ffff13; emissive: #000000; metalness: 0.91; roughness: 0.4"
          rotation="0 0 0"
          networked="template: #cube-template, #int-obj-template; networkId: cube2c"
          simple-rotate="pdRotation: ve2-r; pdToggle: te2-s; minValue: 0; maxValue: 100"
          vr-rotate-interactable="pdRotation: ve2-r; pdToggle: te2-s; minValue: 0; maxValue: 100"
        ></a-entity>

        <a-entity
          geometry="primitive: dodecahedron;radius: 0.5"
          id="sphere2c"
          class="interactable"
          interactable
          networked="template: #sphere-template, #int-obj-template; networkId: sphere2c"
          simple-rotate="pdRotation: fe2-s; pdToggle: tfe2-s; minValue: -40; maxValue: 0"
          vr-rotate-interactable="pdRotation: fe2-s; pdToggle: tfe2-s; minValue: -40; maxValue: 0"
          visible="true"
          position="3 -0.7 2"
          rotation="0 0 0"
          normal-map="#normalMap"
          material="color: #ffff13; emissive: #000000; metalness: 0.91; roughness: 0.4"
        ></a-entity>
        <!------============================-------->

        <a-entity
          position="4 -2 1"
          geometry="primitive:sphere;segmentsHeight: 10; segmentsWidth: 10; segmentsDepth: 2"
          rotation="0 0 0"
          scale="3 0.5 3"
          material="opacity: 0.8; repeat: 2 2; side: double; transparent: true; color: #00AA00;  displacementMap: #floor_tex; displacementScale: -0.4; displacementBias: 0.4;emissive: #00AAAA; emissiveIntensity: 0.37; metalness: 0.3; roughness: 0.44; src: #floor_tex"

        ></a-entity>
      </a-entity>

      <!--
      <a-entity
        geometry="primitive: sphere"
        visible="true"
        id="sphere3a"
        class="interactable"
        interactable
        position="-6 -0.8 -2"
        rotation="0 0 0"
        normal-map="#normalMap"
        random-mesh="complexity: 100; minSize: 0.35; maxSize: 0.55; randomColor: false; color: #ff0000"
        networked="template: #sphere-template, #int-obj-template; networkId: sphere3a"
        simple-rotate="pdRotation: fu-s; pdToggle: tfu-s; minValue: -40; maxValue: 0"
      ></a-entity>

      <a-entity
        geometry="primitive: sphere"
        visible="true"
        id="sphere3b"
        class="interactable"
        interactable
        position="-5 -0.7 -3"
        normal-map="#normalMap"
        random-mesh="complexity: 100; minSize: 0.35; maxSize: 0.55; randomColor: false; color: #0040ff"
        networked="template: #sphere-template, #int-obj-template; networkId: sphere3b"
        simple-rotate="pdRotation: fu1-s; pdToggle: tfu1-s; minValue: -40; maxValue: 0"
      ></a-entity>

      <a-entity
        geometry="primitive: sphere"
        visible="true"
        id="sphere3c"
        class="interactable"
        interactable
        position="-5 -0.7 -1"
        normal-map="#normalMap"
        random-mesh="complexity: 100; minSize: 0.35; maxSize: 0.55; randomColor: false; color: #24c210"
        rotation="0 0 0"
        networked="template: #sphere-template, #int-obj-template; networkId: sphere3c"
        simple-rotate="pdRotation: fu2-s; pdToggle: tfu2-s; minValue: -40; maxValue: 0"
      ></a-entity>


      <a-entity
        geometry="primitive: box"
        visible="true"
        id="cube3a"
        class="interactable"
        interactable
        position="-6 0.7 -2"
        normal-map="#normalMap"
        random-mesh="complexity: 5; minSize: 0.35; maxSize: 0.45; randomColor: false; color: #ff0000; wireframe: true"
        rotation="0 0 0"
        networked="template: #cube-template, #int-obj-template; networkId: cube3a"
        simple-rotate="pdRotation: vu-r; pdToggle: tu-s; minValue: 0; maxValue: 100"
      ></a-entity>

      <a-entity
        geometry="primitive: box"
        visible="true"
        id="cube3b"
        class="interactable"
        interactable
        position="-5 0.7 -3"
        rotation="0 0 0"
        networked="template: #cube-template, #int-obj-template; networkId: cube3b"
        simple-rotate="pdRotation: vu1-r; pdToggle: tu1-s; minValue: 0; maxValue: 100"
        normal-map="#normalMap"
        random-mesh="complexity: 5; minSize: 0.35; maxSize: 0.45; randomColor: false; color: #0040ff; wireframe: true"
      ></a-entity>

      <a-entity
        geometry="primitive: box"
        visible="true"
        id="cube3c"
        class="interactable"
        interactable
        position="-5 0.7 -1"
        normal-map="#normalMap"
        random-mesh="complexity: 5; minSize: 0.35; maxSize: 0.45; randomColor: false; color: #24c210; wireframe: true"
        rotation="0 0 0"
        networked="template: #cube-template, #int-obj-template; networkId: cube3c"
        simple-rotate="pdRotation: vu2-r; pdToggle: tu2-s; minValue: 0; maxValue: 100"
      ></a-entity>
      <a-cylinder
        position="-5 -2 -2"
        normal-map="#normalMap"
        random-mesh="complexity: 15; minSize: 0.6; maxSize: 0.65; randomColor: false; color: #39FF14; wireframe: false"
        scale="4 0.05 4"
      >
      </a-cylinder>
-->

      <a-pdxr
        visualize="false"
        stereo="true"
        src="default.pd"
        position="0 1 0"
      ></a-pdxr>
    </a-scene>
    <svg id="canvas" hidden></svg>

    <script>
      // Called by Networked-Aframe when connected to server
      // Optional to use; this API will change in the future
      function onConnect() {
        console.log("onConnect", new Date());
      }
    </script>
  </body>
</html>
